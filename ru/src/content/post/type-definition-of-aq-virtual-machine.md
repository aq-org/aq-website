---
publishDate: 2024-07-24T15:35:00+08:00
title:  Определение типа виртуальной машины AQ — AQ
excerpt: Поскольку разные системы, оборудование и другие внешние условия имеют разную поддержку и определения памяти, чтобы виртуальная машина AQ соответствовала требованиям кроссплатформенной работы, важно разработать единый стандарт типа. В этой статье определяются и стандартизируются типы виртуальных машин AQ, чтобы гарантировать нормальную работу виртуальных машин AQ в разных системах.
image: https://www.axa6.com/aq.png
category: Blog
tags:
  - AQ
  - Blog
metadata:
  canonical: https://www.axa6.com/ru/type-definition-of-aq-virtual-machine
---

# Введение
Поскольку разные «системы», «аппаратное обеспечение» и другие внешние условия имеют разную поддержку и определения «памяти», для того, чтобы «виртуальная машина AQ» отвечала требованиям *кроссплатформенной* работы, необходимо разработать унифицированный стандарт «типа». В этой статье определяются и стандартизируются типы виртуальных машин AQ, чтобы гарантировать нормальную работу виртуальных машин AQ в разных системах. </br>

# Идеи дизайна
Прежде всего, чтобы добиться упрощения «типов» и повышения *эффективности* работы, конструкция «родных типов» («типов», которые *напрямую* поддерживаются виртуальной машиной без определения через код) должна быть такой: как можно меньше. Поэтому для связанных *сложных типов*, таких как «перечисление», «структура» и т. д., мы разрабатываем их на уровне «компилятора», чтобы уменьшить количество «типов» и «сложность» «виртуальной машины». </br>

> Согласно определению `type` в `AqvmMemory_Memory` в `memory.h`, каждый `uint8_t` хранит `2` типа`, поэтому количество `types` должно быть между `0x00`-`0x0F` (16 ) между. </br>

Во-вторых, исследуя «типы» других «языков программирования», мы обобщили общие «типы». Мы разработали следующие «типы» для достижения *производительности* и *простоты* «виртуальной машины». `баланс. </br>

0. ноль - *пустой тип*
1. байт - *`1`байтовый целочисленный тип со знаком*
2. int - *`4`-байтовый целочисленный тип со знаком*
3. long - *8-байтовый целочисленный тип со знаком*
4. float - *`4` тип с плавающей запятой одинарной точности*
5. double - *`8`байтовый тип с плавающей запятой двойной точности*

Наконец, мы разработали подробные «стандарты» для «типов», чтобы гарантировать, что «виртуальная машина AQ» может обеспечить «кроссплатформенную» работу. </br>

> Чтобы сократить определение типа «виртуальной машины», «беззнаковые типы» будут реализованы на уровне «компилятора».

## Определения типов для других `языков программирования`
Чтобы сделать «типы» AQ более обширными и простыми для понимания разработчиками, мы обращаемся к определениям «типов» существующих распространенных «языков программирования». </br>
Определенные ниже «базовые типы» представляют собой общие типы «данных», такие как целые числа, числа с плавающей запятой и пустые типы. Он выполняет базовую работу по хранению данных или имеет особое значение. </br>

### С
Текущий стандарт «C» — «ISO/IEC 9899:2018 Информационные технологии. Языки программирования — C». Поскольку авторские права на этот стандарт принадлежат ISO (Международной организации по стандартизации) и IEC (Международной электротехнической комиссии), во избежание споров об авторских правах мы суммировали определения «типов». То же самое ниже. </br>

Официальный сайт: https://www.iso.org/standard/74528.html</br>

1. `_Bool` — объект, объявленный как тип `_Bool`, достаточно велик для хранения значений `0` и `1`.
2. `(unsigned) char` — тип символа. Объект, объявленный как тип char, достаточно велик для хранения любого члена базового набора символов выполнения. Если член базового набора символов выполнения хранится в объекте char, его значение гарантированно будет неотрицательным. Если в символьном объекте хранятся какие-либо другие символы, результирующее значение определяется реализацией, но должно находиться в диапазоне значений, которые могут быть представлены в этом типе.
3. `signed char` — тип знакового символа.
4. `short int` - расширенный целочисленный тип со знаком.
5. `unsigned short int` — расширенный беззнаковый целочисленный тип.
6. `int` — расширенный стандартный целочисленный тип со знаком.
7. `unsigned int` – стандартный беззнаковый целочисленный тип.
8. `long int` — расширенный целочисленный тип со знаком.
9. `unsigned long int` – расширенный целочисленный тип без знака.
10. `long long int` – расширенный целочисленный тип со знаком.
11. `unsigned long long int` — расширенный беззнаковый целочисленный тип.
12. `float` - Тип с плавающей запятой. Набор значений типа float является подмножеством набора значений типа double.
13. `double` - тип с плавающей запятой. Набор значений типа double — это подмножество набора значений типа long double.
14. `long double` — тип с плавающей запятой.
15. `void`. Тип `void` содержит набор нулевых значений. Это неполный тип объекта, который не может быть реализован.

Кроме того, в C есть и другие небазовые типы, такие как типы перечисления (типы enum), типы указателей и т. д. Это не будет обсуждаться при проектировании «виртуальной машины». </br>

### `C++` и другие варианты `C`
Текущий стандарт C++ — ISO/IEC 14882:2020 Языки программирования — C++. Поскольку `C++` и другие варианты `C` по сути являются теми же типами, что и `C`, они больше не указаны. </br>

###Питон
Последняя официальная версия Python — 3.12.4. Встроенные типы в документации Python 3.12.4 документируют стандартные типы, встроенные в интерпретатор Python. </br>
Основными встроенными типами являются «Число», «Последовательность», «Карта», «Класс», «Экземпляр» и «Исключение». Из-за нехватки места контент, отличный от «базовых типов», здесь обсуждаться не будет. </br>

Ссылка на источник: https://docs.python.org/zh-cn/3/library/stdtypes.html</br>

1. `int` - *integer* `int` имеет бесконечную точность. Немодифицированные целочисленные литералы (включая шестнадцатеричные, восьмеричные и двоичные числа) создают целые числа.
2. `float` — *число с плавающей запятой* `Float` запятая` обычно реализуется в `C` с использованием `double`. Числовые литералы, содержащие десятичную точку или знак степени, создают число с плавающей запятой.
3. `комплекс` - *Комплексное число* Комплексное число состоит из "действительной части" и "мнимой части", каждая часть представляет собой "число с плавающей запятой". Добавляя «j» или «J» после числового литерала, вы можете получить «мнимое число» (комплексное число с действительной частью нуля). Добавьте его к «целому» или «числу с плавающей запятой». получить «мнимое число» «комплексное число» с действительной и мнимой частью.
4. `bool` - *Boolean* `Boolean` также является `подтипом` `integer`. Логический объект, представляющий истинное значение. Тип bool имеет только два экземпляра констант: True и False.
5. `list` - *List* `List` — это `изменяемая последовательность`, обычно используемая для хранения `наборов` похожих элементов (где точная степень сходства будет варьироваться в зависимости от приложения).
6. `tuple` - *Tuple* `Tuple` — это `неизменяемая последовательность`, обычно используемая для хранения `наборов из нескольких элементов` разнородных данных (например, `binary`, генерируемых встроенной функцией `enumerate()`). группа`). «Кортежи» также используются в ситуациях, когда требуется «неизменяемая последовательность» однородных данных (например, позволяющая хранить экземпляры «set» или «dict»).
7. `range`. Тип `range` представляет собой `неизменяемую` `числовую последовательность`, обычно используемую для повторения заданного количества раз в цикле `for`.
8. `str` - *Тип текстовой последовательности* Для обработки текстовых данных в `Python` вы используете объект `str`, также называемый `string`. «Строка» — это «неизменяемая последовательность» кодовых точек Unicode.
9. `bytes`. Объект `bytes` представляет собой `неизменяемую последовательность` отдельных байтов. Поскольку многие основные двоичные протоколы основаны на текстовой кодировке ASCII, объект bytes предоставляет некоторые методы, которые доступны только при работе с ASCII-совместимыми данными и во многих функциях тесно связаны со строковыми объектами.
10. `byteearray`. Объект `byteearray` является изменяемым аналогом объекта `bytes`.
11. `memoryview` - *Memory view* Объект `memoryview` позволяет коду Python получать доступ к внутренним данным объекта, если объект поддерживает `буферный протокол` без создания копии.
12. `set` - *set type* Объект `set` представляет собой `неупорядоченный набор из нескольких элементов`, состоящий из уникальных `хешируемых` объектов. Обычное использование включает обнаружение членства, удаление дубликатов из последовательностей и математические вычисления множеств, такие как пересечение, объединение, разность, симметричная разность и т. д. Тип `set` является изменчивым, и его содержимое можно изменить с помощью таких методов, как `add()` и `remove()`. Поскольку это изменяемый тип, он не имеет хеш-значения и не может использоваться в качестве ключа в словаре или элемента в коллекции.
13. `frozenset` - *Тип коллекции* Тип `frozenset` является `неизменяемым` и `хэшируемым`. Его содержимое не может быть изменено после его создания, поэтому его можно использовать как `ключ` `словаря` или другое `Элемент` `набора`.
14. `dict` - *Тип сопоставления* Объект `mapping` сопоставляет хешируемое значение с любым объектом. «Карта» — это «изменяемый объект». В настоящее время существует только один стандартный тип отображения «словарь».
15. `GenericAlias`. Объекты `GenericAlias` обычно создаются путём `извлечения` `класса`. Чаще всего они используются с «классами-контейнерами», такими как «list» или «dict». Например, объект GenericAlias ​​list[int] создается путем извлечения класса list с параметром int. Основное назначение объектов GenericAlias ​​— аннотация типа.
16. `union`. `union` объект` содержит значение выполнения операции `| (побитовое ИЛИ)` для нескольких `типовых объектов`. Эти типы в основном используются для «аннотаций типов». По сравнению с typing.Union, выражения `union type` обеспечивают более краткий синтаксис подсказки типа.

###Джава
«Спецификация» «JVM (виртуальная машина Java)» — это «Спецификация виртуальной машины Java®», последняя версия — «Java SE 22 Edition», а дата выпуска — «2024-02-09». По сравнению с «определением типа» на уровне «компилятора» других языков ситуация с «JVM» больше соответствует конструкции «виртуальной машины». При этом типы JVM делятся на примитивные типы и ссылочные типы. В связи с потребностями разработки виртуальной машины мы выбрали для обсуждения примитивные типы. </br>
Кроме того, у Java также есть спецификация, которая называется «Спецификация языка Java, Java SE 22 Edition», ссылка на HTML: https://docs.oracle.com/javase/specs/jls/se22/ html. /index.html Ссылка `PDF`: https://docs.oracle.com/javase/specs/jls/se22/jls22.pdf. Из-за особых потребностей разработки «виртуальных машин» в этой статье мы решили изучить «определение типа» в «JVM», а не «определение типа» в языке «Java».</br>

Ссылка на источник (HTML): https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-2.html#jvms-2.3</br>
Ссылка на источник (PDF): https://docs.oracle.com/javase/specs/jvms/se22/jvms22.pdf</br>

1. `byte` — *целочисленный тип*, значение которого представляет собой `8`-битное *знаковое целое число с дополнением до двух*, а его значение по умолчанию равно `нолю`. От `-128` до `127` (от *-2<sup>7</sup>* до *2<sup>7</sup> – 1*) включительно.
2. `short` — *целочисленный тип*, значение которого представляет собой `16`-битное *знаковое дополнение до двух*, а его значение по умолчанию — `ноль`. От `-32768` до `32767` (от *-2<sup>15</sup>* до *2<sup>15</sup> – 1*) включительно.
3. `int` - *целочисленный тип*, значение которого представляет собой `32` битное *знаковое дополнение до двух*, а его значение по умолчанию равно `нолю`. От `-2147483648` до `2147483647` (от *-2<sup>31</sup>* до *2<sup>31</sup> – 1*) включительно.
4. `long` — *целочисленный тип*, значение которого представляет собой `64` битное *знаковое дополнение до двух* и чье значение по умолчанию равно `нолю`. От `-9223372036854775808` до `9223372036854775807` (от *-2<sup>63</sup>* до *2<sup>63</sup> – 1*) включительно.
5. `char` - *Целочисленный тип* Его значение представляет собой 16-битное *целое число без знака*, представляющее кодовую точку Unicode в базовой многоязычной плоскости, закодированное как `UTF-16`, а его значение по умолчанию — ` null `Кодовая точка(`\u0000`). От «0» до «65535».
6. `float` - *Тип с плавающей запятой* Его значение полностью соответствует `32`-битному формату *IEEE 754binary32*, а значением по умолчанию является `положительный ноль`.
7. `double` — *Тип с плавающей запятой* Его значение точно такое же, как значение в `64`-битном формате *IEEE 754binary64*, а значение по умолчанию — `положительный ноль`.

# Подробные стандарты
## Определение типа
Сложные типы будут обрабатываться компилятором, чтобы обеспечить простоту и эффективность виртуальной машины. Простые типы будут напрямую поддерживаться виртуальной машиной. </br>
Ниже приведены `6` базовых типов, определенных `виртуальной машиной AQ`:</br>

> Типы, которые не поддерживаются напрямую, включают «целое число без знака», «адрес памяти (указатель)», «строку» и т. д. Эти типы будут реализованы на уровне компилятора. Для «виртуальных машин» эти типы реализуются косвенно.

0. `null` - `0x00` - ***пустой тип***</br>
Пустые типы представляют только неизвестные типы или типы, которые не нужно использовать (например: нет возврата). Никакой длины. </br>

1. `byte` - `0x01` - ***`1` байт (`8` бит) целочисленный тип со знаком***</br>
Хранится в *двойном дополнении*. Обычно используется для хранения `bool` или `char`. От `-128` до `127` (от *-2<sup>7</sup>* до *2<sup>7</sup> – 1*) включительно. </br>

2. `int` - `0x02` - ***`4` байт (`32` бит) целочисленный тип со знаком***</br>
Хранится в *двойном дополнении*. От `-2147483648` до `2147483647` (от *-2<sup>31</sup>* до *2<sup>31</sup> – 1*) включительно. </br>

3. `long` - `0x03` - ***`8` байт (`64` бит) целочисленный тип со знаком***</br>
Хранится в *двойном дополнении*. `Адрес памяти (указатель)` также сохраняется с использованием этого параметра. Его значение представляет собой `64` битное целое число со знаком, дополняемое до двух*, а его значение по умолчанию – `ноль`. От `-9223372036854775808` до `9223372036854775807` (от *-2<sup>63</sup>* до *2<sup>63</sup> – 1*) включительно. </br>

4. `float` - `0x04` - ***`4` байт (`32` бит) тип с плавающей запятой одинарной точности***</br>
Принимает стандарт ISO/IEC 60559 «Информационные технологии. Микропроцессорные системы. Арифметика с плавающей запятой». </br>

5. `double` - `0x05` - ***`8` байт (`64` бит) тип двойной точности с плавающей запятой***</br>
Принимает стандарт ISO/IEC 60559 «Информационные технологии. Микропроцессорные системы. Арифметика с плавающей запятой». </br>

### Дополняющий код
#### Определение
«Дополнение» — это *представление чисел со знаком в компьютерах*. </br>

#### метод
«Дополнительный код» для «положительных чисел» и «0» — это *само число плюс старший бит 0*. «Дополнением» к «отрицательному числу» является *поразрядное изменение его абсолютного значения и добавление 1*. </br>

### Стандарт с плавающей запятой
#### Определение
«Стандарт чисел с плавающей запятой» соответствует стандарту «ISO/IEC 60559 «Информационные технологии — микропроцессорные системы — арифметика с плавающей запятой». Этот стандарт также называется «Стандарт IEEE двоичной арифметики с плавающей запятой (IEEE 754)»</br>

Официальный сайт: https://www.iso.org/standard/80985.html</br>

#### метод
«Фактическое значение» «числа с плавающей запятой» равно «биту знака», умноженному на «значение смещения экспоненты», умноженное на «дробное значение». Подробные определения см. в стандарте «ISO/IEC 60559 Информационные технологии. Микропроцессорные системы. Арифметика с плавающей запятой». </br>

##### `32` бит `число с плавающей запятой`
| Длина бита | Имя бита |
------ | ------ |
| 1 | Знаковый бит 31 |
8 | Число | от 30 до 23 положительное значение (фактический размер показателя + 127) |
23 | Допустимые цифры | От 22 до 0 цифр (начиная с 0 справа) |

##### `64` бит `число с плавающей запятой`
| Длина бита | Имя бита |
------ | ------ |
| 1 | Знаковый бит |
11 | Число | от 62 до 52 положительное значение (фактический размер показателя + 1023) |
52 | Допустимые цифры | Числа от 51 до 0 (начиная с 0 справа) |


## `types.h` полный код:
Существуют также соответствующие коды для `type`. Ниже приведен код `types.h`:</br>

```C
// Copyright 2024 AQ author, All Rights Reserved.
// This program is licensed under the AQ License. You can find the AQ license in
// the root directory.

#ifndef AQ_AQVM_MEMORY_TYPES_H_
#define AQ_AQVM_MEMORY_TYPES_H_

#include <stdint.h>

// null - 0x00 - null type
// The null type simply represents an unknown type or a type that is not needed
// (e.g., returns nothing). Has no length.
typedef void aqnull;

// byte - 0x01 - 1 byte (8-bit) signed integer type
// Using two's complement storage. Generally used to store bool or char. From
// -128 to 127 (-2^7 to 2^7 - 1), inclusive.
typedef int8_t aqbyte;

// int - 0x02 - 4-byte (32-bit) signed integer type
// Stored in two's complement notation. From -2147483648 to 2147483647 (-2^31 to
// 2^31 - 1), inclusive.
typedef int aqint;

// long - 0x03 - 8-byte (64-bit) signed integer type
// Stored in two's complement notation. From -9223372036854775808 to
// 9223372036854775807 (-2^63 to 2^63 - 1), inclusive.
typedef int64_t aqlong;

// float - 0x04 - 4-byte (32-bit) single-precision floating point type
// Using ISO/IEC 60559 Information technology — Microprocessor Systems —
// Floating-Point arithmetic standard.
typedef float aqfloat;

// double - 0x05 - 8-byte (64-bit) double-precision floating point type
// Using ISO/IEC 60559 Information technology — Microprocessor Systems —
// Floating-Point arithmetic standard.
typedef double aqdouble;

// The part beyond 0x05 and within 0x0F is currently designated as a reserved
// type. The part beyond 0x0F cannot be used because it exceeds the 4-bit size
// limit.

#endif
```

> Мы усердно работаем над разработкой «Виртуальной машины AQ». Если вы хотите получить дополнительную информацию или принять участие в разработке, посетите наш официальный сайт: https://www.axa6.com и Github: https://github.com/aq-org/AQ. </br>

> Эта статья опубликована на основе лицензии AQ: https://github.com/aq-org/AQ/blob/main/LICENSE. При необходимости адаптируйте или перепечатайте ее в соответствии с лицензией AQ.