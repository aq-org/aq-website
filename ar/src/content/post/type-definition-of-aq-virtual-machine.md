---
publishDate: 2024-07-22T23:17:00+08:00
title:  تعريف النوع للجهاز الظاهري AQ - AQ
excerpt: نظرًا لأن الأنظمة والأجهزة والظروف الخارجية الأخرى المختلفة لها دعم وتعريفات مختلفة للذاكرة، لكي يلبي الجهاز الظاهري AQ متطلبات التشغيل عبر الأنظمة الأساسية، فمن الضروري تصميم معيار نوع موحد. تحدد هذه المقالة أنواع أجهزة AQ الافتراضية وتوحيدها للتأكد من إمكانية تشغيل أجهزة AQ الافتراضية الموجودة على أنظمة مختلفة بشكل طبيعي.
image: https://www.axa6.com/aq.png
category: Blog
tags:
  - AQ
  - Blog
metadata:
  canonical: https://www.axa6.com/type-definition-of-aq-virtual-machine
---

# مقدمة
نظرًا لأن "الأنظمة" و"الأجهزة" والظروف الخارجية الأخرى المختلفة لها دعم وتعريفات مختلفة لـ "الذاكرة"، فمن أجل جعل "الجهاز الظاهري AQ" يلبي متطلبات التشغيل *عبر الأنظمة الأساسية*، فمن الضروري تصميم معيار "النوع" الموحد لا غنى عنه. تحدد هذه المقالة أنواع أجهزة AQ الافتراضية وتوحيدها للتأكد من إمكانية تشغيل أجهزة AQ الافتراضية الموجودة على أنظمة مختلفة بشكل طبيعي. </br>

# أفكار التصميم
أولاً وقبل كل شيء، من أجل تحقيق تبسيط "الأنواع" وزيادة *كفاءة التشغيل*، يجب أن يكون تصميم "الأنواع الأصلية" ("الأنواع" التي يدعمها الجهاز الظاهري *بشكل مباشر* دون تعريفها من خلال التعليمات البرمجية) كما يلي: أقل ما يمكن. لذلك، بالنسبة إلى *الأنواع المعقدة* ذات الصلة، مثل "التعداد"، و"البنية"، وما إلى ذلك، فإننا نقوم بتطويرها على مستوى "المترجم" لتقليل عدد "الأنواع" و"التعقيد" في "الجهاز الافتراضي". </br>

> وفقًا لتعريف `النوع` في `AqvmMemory_Memory` في `memory.h`، يقوم كل `uint8_t` بتخزين `2` نوعين، لذلك يجب أن يكون عدد `الأنواع` بين `0x00`-`0x0F` (16) بين. </br>

ثانيًا، من خلال البحث عن "أنواع" "لغات البرمجة" الأخرى، قمنا بتلخيص "الأنواع" الشائعة وقمنا بتصميم "الأنواع" التالية لتحقيق *أداء* و *بساطة* "الآلة الافتراضية". `التوازن. </br>

0. null - *نوع فارغ*
1. byte - *`1` نوع عدد صحيح موقّع بالبايت*
2. int - *`4` بايت نوع عدد صحيح مُوقع*
3. long - *`8` بايت نوع عدد صحيح مُوقع*
4. float - *`4` بايت نوع النقطة العائمة بدقة واحدة*
5. double - *`8` بايت نوع النقطة العائمة بدقة واحدة*

أخيرًا، قمنا بتصميم "معايير" تفصيلية لـ "الأنواع" لضمان قدرة "جهاز AQ الظاهري" على تحقيق التشغيل "عبر الأنظمة الأساسية". </br>

> من أجل تقليل تعريف نوع "الجهاز الظاهري"، سيتم تنفيذ "الأنواع غير الموقعة" على مستوى "المترجم".

## تعريفات "النوع" لـ "لغات البرمجة" الأخرى
من أجل جعل "أنواع" AQ أكثر شمولاً وأسهل على المطورين فهمها، نشير إلى تعريفات "النوع" الخاصة بـ "لغات البرمجة" الشائعة الموجودة. </br>
"الأنواع الأساسية" المحددة أدناه هي أنواع "بيانات" عامة مثل الأعداد الصحيحة وأرقام الفاصلة العائمة والأنواع الفارغة. يتولى أعمال تخزين البيانات الأساسية أو له أهمية خاصة. </br>

### ج
المعيار "C" الحالي هو "ISO/IEC 9899:2018 تكنولوجيا المعلومات - لغات البرمجة - C". نظرًا لأن حقوق الطبع والنشر لهذا المعيار تعود إلى "ISO (المنظمة الدولية للمعايير)" ​​و"IEC (اللجنة الكهروتقنية الدولية)"، ومن أجل تجنب النزاعات حول حقوق الطبع والنشر، فقد قمنا بتلخيص تعريفات "النوع". نفس أدناه. </br>

الموقع الرسمي: https://www.iso.org/standard/74528.html</br>

1. `_Bool` - الكائنات التي تم تعريفها كنوع `_Bool` كبيرة بما يكفي لتخزين القيمتين `0` و`1`.
2. `(unsigned) char` - نوع الحرف. الكائن المُعلن كنوع char كبير بما يكفي لتخزين أي عضو في مجموعة أحرف التنفيذ الأساسية. إذا تم تخزين أحد أعضاء مجموعة أحرف التنفيذ الأساسية في كائن `char`، فسيتم ضمان أن تكون قيمته غير سالبة. إذا تم تخزين أي أحرف أخرى في كائن حرف، فإن القيمة الناتجة هي "محددة التنفيذ"، ولكن يجب أن تكون ضمن نطاق القيم التي يمكن تمثيلها في هذا النوع.
3. `signed char` - نوع الحرف الموقع.
4. `short int` - نوع عدد صحيح موقّع ممتد.
5. `unsigned short int` - نوع عدد صحيح ممتد غير موقع.
6. `int` - نوع عدد صحيح موقّع قياسي ممتد.
7. `unsigned int` - نوع عدد صحيح قياسي غير موقع.
8. `long int` - نوع عدد صحيح موقّع ممتد.
9. `unsigned long int` - نوع عدد صحيح ممتد غير موقع.
10. `long long int` - نوع عدد صحيح موقّع ممتد.
11. `unsigned long long int` - نوع عدد صحيح ممتد غير موقع.
12. `float` - نوع النقطة العائمة. مجموعة القيم من النوع "العائم" هي مجموعة فرعية من مجموعة القيم من النوع "مزدوج".
13. `double` - نوع النقطة العائمة. مجموعة القيم من النوع `مزدوج` هي مجموعة فرعية من مجموعة قيم من النوع `مزدوج طويل`.
14. `long double` - نوع النقطة العائمة.
15. `void` - يحتوي النوع `void` على مجموعة من القيم الخالية، وهو نوع كائن غير مكتمل ولا يمكن تنفيذه.

بالإضافة إلى ذلك، تحتوي لغة C أيضًا على أنواع أخرى غير "أساسية"، مثل أنواع "التعداد" (أنواع "التعداد")، وأنواع المؤشر، وما إلى ذلك. لن تتم مناقشته في تصميم "الجهاز الظاهري". </br>

### `C++` ومتغيرات `C` الأخرى
معيار `C++` الحالي هو `ISO/IEC 14882:2020 Programming languages — C++`. نظرًا لأن `C++` ومتغيرات `C` الأخرى هي في الأساس نفس أنواع `C`، فلم تعد مدرجة في القائمة بعد الآن. </br>

### Python
أحدث إصدار رسمي من `Python` هو "3.12.4". الأنواع المضمنة في وثائق Python 3.12.4 توثق الأنواع القياسية المضمنة في مترجم Python. </br>
الأنواع الرئيسية المضمنة هي `Number` و`Sequence` و`Map` و`Class` و`Instance` و`Exception`. لأسباب تتعلق بالمساحة، لن تتم مناقشة المحتوى بخلاف "الأنواع الأساسية" هنا. </br>

رابط المصدر: https://docs.python.org/zh-cn/3/library/stdtypes.html</br>

1. `int` - *عدد صحيح* `عدد صحيح` له دقة لا نهائية. تنتج الأعداد الصحيحة غير المعدلة (بما في ذلك الأرقام السداسية العشرية والثمانية والثنائية) أعدادًا صحيحة.
2. `float` - *أرقام الفاصلة العائمة* عادةً ما يتم تنفيذ "أرقام الفاصلة العائمة" في لغة "C" باستخدام "مزدوج". تنتج القيم الحرفية الرقمية التي تحتوي على علامة عشرية أو علامة أس رقمًا عائمًا.
3. `complex` - *الأعداد المركبة* تحتوي الأعداد المركبة على "جزء حقيقي" و"جزء تخيلي"، وكل جزء هو "رقم فاصلة عائمة". من خلال إضافة `j` أو `J` بعد عدد حرفي، يمكنك الحصول على `رقم وهمي` `رقم مركب` بجزء حقيقي من الصفر، قم بإضافته إلى `عدد صحيح` أو `رقم النقطة العائمة` الحصول على "عدد وهمي" "عدد مركب" مع الجزء الحقيقي والجزء التخيلي.
4. `bool` - *Boolean* Boolean هو أيضًا نوع فرعي من الأعداد الصحيحة. كائن منطقي يمثل قيمة حقيقية. يحتوي النوع "bool" على حالتين ثابتتين فقط: "True" و"False".
5. `list` - *القائمة* "القائمة" هي "تسلسل قابل للتغيير"، تُستخدم عادةً للاحتفاظ "بمجموعة" من العناصر المتشابهة (حيث ستختلف درجة التشابه الدقيقة اعتمادًا على التطبيق).
6. `tuple` - *Tuple* `Tuple` هو ``تسلسل غير قابل للتغيير``، يُستخدم عادة لتخزين `مجموعات متعددة العناصر` من البيانات غير المتجانسة (مثل `الصفوف` التي تنتجها الدالة `enumerate()` المضمنة). تُستخدم "الصفوف" أيضًا في المواقف التي تتطلب "تسلسلًا غير قابل للتغيير" من البيانات المتجانسة (على سبيل المثال، السماح بتخزين مثيلات "set" أو "dict").
7. `range` - يمثل النوع "النطاق" "تسلسلًا رقميًا" "غير قابل للتغيير" ويستخدم عادةً للتكرار لعدد محدد من المرات في حلقة "for".
8. `str` - *نوع تسلسل النص* تستخدم معالجة البيانات النصية في "Python" الكائن "str"، المعروف أيضًا باسم "string". "السلسلة" هي "تسلسل غير قابل للتغيير" لنقاط كود "Unicode".
9. `bytes` - كائن "البايتات" هو "تسلسل غير قابل للتغيير" من البايتات الفردية. نظرًا لأن العديد من البروتوكولات الثنائية الرئيسية تعتمد على ترميز نص ASCII، فإن كائن البايت يوفر بعض الأساليب المتوفرة فقط عند العمل مع البيانات المتوافقة مع ASCII وترتبط ارتباطًا وثيقًا بكائنات السلسلة في العديد من الميزات.
10. `bytearray` - `byteearray' - كائن `byteearray` هو النظير القابل للتغيير لكائن `bytes`.
11. `memoryview` - `memoryview` - *عرض الذاكرة* يسمح كائن `memoryview` لكود `Python` بالوصول إلى البيانات الداخلية للكائن، طالما أن الكائن يدعم ``بروتوكول المخزن المؤقت`` دون عمل نسخة.
12. `set` - `set` - *نوع المجموعة* كائن `set` هو عبارة عن مجموعة غير مرتبة متعددة العناصر تتكون من كائنات فريدة قابلة للتجزئة. تشمل الاستخدامات الشائعة اكتشاف العضوية، وإزالة التكرارات من التسلسلات، وتعيين العمليات الحسابية في الرياضيات، مثل التقاطع والاتحاد والفرق والفرق المتماثل وما إلى ذلك. النوع `set` قابل للتغيير، ويمكن تغيير محتوياته باستخدام طرق مثل `add()` و`remove()`. نظرًا لأنه نوع قابل للتغيير، فهو لا يحتوي على قيمة تجزئة ولا يمكن استخدامه كمفتاح في قاموس أو عنصر في مجموعة.
13. `frozenset` - `frozenset` - *نوع المجموعة* نوع `frozenset` هو `غير قابل للتغيير` و`قابل للتجزئة`، ولا يمكن تغيير محتوياته بعد إنشائه، لذلك يمكن استخدامه كـ `مفتاح` لـ `قاموس` أو غيره` مجموعة "العنصر" من.
14. `dict` - `dict` - *نوع التعيين* سيقوم كائن `تعيين' بتعيين قيمة `قابلة للتجزئة` إلى كائن عشوائي. "الخريطة" هي "كائن قابل للتغيير". يوجد حاليًا نوع تعيين قياسي واحد فقط "قاموس".
15. `GenericAlias` - "الاسم المستعار العام" - عادةً ما يتم إنشاء كائنات "الاسم المستعار العام" عن طريق "استخراج" "فئة". يتم استخدامها بشكل شائع مع "فئات الحاويات" مثل "list" أو "dict". على سبيل المثال، يتم إنشاء كائن `GenericAlias` `list[int]` عن طريق استخراج فئة `list` باستخدام المعلمة `int`. الغرض الرئيسي من كائنات "GenericAlias" هو "التعليق التوضيحي للنوع".
16. `union` - ``union` - يحتوي ``كائن الاتحاد`` على قيمة العملية `|(bitwise OR)` التي يتم تنفيذها على `كائنات نوع` متعددة. تُستخدم هذه الأنواع بشكل أساسي في "التعليقات التوضيحية للنوع". مقارنةً بـ Typing.Union، تتيح تعبيرات "نوع الاتحاد" صياغة أكثر إيجازًا لتلميحات النوع.

### Java
"مواصفات" JVM (Java Virtual Machine) هي "مواصفات Java® Virtual Machine"، وأحدث إصدار هو "Java SE 22 Edition"، وتاريخ الإصدار هو "2024-02-09". بالمقارنة مع "تعريف النوع" على مستوى "المترجم" للغات الأخرى، فإن وضع "JVM" أكثر انسجامًا مع تصميم "الجهاز الظاهري". في الوقت نفسه، تنقسم أنواع JVM إلى أنواع بدائية وأنواع مرجعية نظرًا لاحتياجات تطوير الآلة الافتراضية، اخترنا الأنواع البدائية للمناقشة. </br>
بالإضافة إلى ذلك، تحتوي `Java` أيضًا على ``مواصفات`` وهي ``مواصفات لغة Java، إصدار Java SE 22``، رابط `HTML`: https://docs.Oracle.com/javase/specs/jls/se22/ html /index.html رابط `PDF`: https://docs.Oracle.com/javase/specs/jls/se22/jls22.pdf. نظرًا للاحتياجات الخاصة لتطوير "الآلة الافتراضية"، تختار هذه المقالة دراسة "تعريف النوع" لـ "JVM" بدلاً من "تعريف النوع" للغة "Java".</br>

رابط المصدر (HTML): https://docs.Oracle.com/javase/specs/jvms/se22/html/jvms-2.html#jvms-2.3</br>
رابط المصدر (PDF): https://docs.Oracle.com/javase/specs/jvms/se22/jvms22.pdf</br>

1. `byte` - *نوع عدد صحيح* قيمته `8` بت *عدد صحيح مكمل لاثنين*، وقيمته الافتراضية هي `صفر`. من `-128` إلى `127` (*-2<sup>7</sup>* إلى *2<sup>7</sup> - 1*)، شاملاً.
2. `short` - *نوع عدد صحيح* تبلغ قيمته `16` بت *عددًا صحيحًا مكملاً لاثنين مُوقعين*، وقيمته الافتراضية هي `صفر`. من `-32768` إلى `32767` (*-2<sup>15</sup>* إلى *2<sup>15</sup> - 1*)، شاملاً.
3. `int` - *نوع عدد صحيح* تبلغ قيمته `32` بت *عددًا صحيحًا مكملاً لاثنين مُوقعين* وقيمته الافتراضية هي `صفر`. من `-2147483648` إلى `2147483647` (*-2<sup>31</sup>* إلى *2<sup>31</sup> - 1*)، شاملاً.
4. `long` - *نوع عدد صحيح* تبلغ قيمته `64` بت *عددًا صحيحًا مكملاً لاثنين مُوقعين* وقيمته الافتراضية هي `صفر`. من `-9223372036854775808` إلى `9223372036854775807` (*-2<sup>63</sup>* إلى *2<sup>63</sup> - 1*)، شاملاً.
5. `char` - *نوع عدد صحيح* قيمته هي `16` بت *عدد صحيح غير موقّع*، يمثل نقطة كود `Unicode` في المستوى الأساسي متعدد اللغات، المشفر كـ `UTF-16`، وقيمته الافتراضية هي ` `نقطة الرمز(`\u0000`) خالية. من `0` إلى `65535`.
6. `float` - *نوع النقطة العائمة* تتوافق قيمته تمامًا مع تنسيق `32` بت *IEEE 754 ثنائي 32*، والقيمة الافتراضية هي `صفر موجب`.
7. `double` - *نوع النقطة العائمة* قيمته هي نفس القيمة تمامًا بتنسيق `64` بت *IEEE 754 ثنائي64*، والقيمة الافتراضية هي `صفر موجب`.

# معايير مفصلة
## تعريف النوع
ستتم معالجة الأنواع المعقدة بواسطة المترجم لضمان بساطة وكفاءة الجهاز الظاهري، وسيتم دعم الأنواع البسيطة مباشرة بواسطة الجهاز الظاهري. </br>
فيما يلي الأنواع الأساسية "6" التي يحددها "جهاز AQ الظاهري":</br>

> تشمل الأنواع غير المدعومة بشكل مباشر "عددًا صحيحًا غير موقّع"، و"عنوان الذاكرة (المؤشر)"، و"سلسلة"، وما إلى ذلك. سيتم تنفيذ هذه الأنواع على مستوى "المترجم". بالنسبة إلى "الأجهزة الافتراضية"، يتم تنفيذ هذه الأنواع بشكل غير مباشر.

0. `null` - `0x00` - ***نوع فارغ***</br>
الأنواع الفارغة تمثل فقط الأنواع غير المعروفة أو الأنواع التي لا تحتاج إلى استخدامها (على سبيل المثال: بلا إرجاع). لا طول. </br>

1. `byte` - `0x01` - ***`1` بايت (`8` بت) نوع عدد صحيح موقّع***</br>
مخزنة في *مكملين*. يُستخدم بشكل عام لتخزين "bool" أو "char". من `-128` إلى `127` (*-2<sup>7</sup>* إلى *2<sup>7</sup> - 1*)، شاملاً. </br>

2. `int` - `0x02` - ***`4` بايت (`32` بت) نوع عدد صحيح موقّع***</br>
مخزنة في *مكملين*. من `-2147483648` إلى `2147483647` (*-2<sup>31</sup>* إلى *2<sup>31</sup> - 1*)، شاملاً. </br>

3. `long` - `0x03` - ***`8` بايت (`64` بت) نوع عدد صحيح موقّع***</br>
مخزنة في *مكملين*. يتم أيضًا تخزين "عنوان الذاكرة (المؤشر)" باستخدام هذا. قيمته هي 64 بت *عدد صحيح مكمل لتوقيع اثنين* وقيمته الافتراضية هي صفر. من `-9223372036854775808` إلى `9223372036854775807` (*-2<sup>63</sup>* إلى *2<sup>63</sup> - 1*)، شاملاً. </br>

4. `float` - `0x04` - ***`4` بايت (`32`بت) نوع النقطة العائمة بدقة واحدة***</br>
يعتمد معيار `ISO/IEC 60559 Information technology — Microprocessor Systems — Floating-Point arithmetic`. </br>

5. `double` - `0x05` -  ***`8` بايت (`64`بت) نوع النقطة العائمة بدقة واحدة***</br>
采用`ISO/IEC 60559 Information technology — Microprocessor Systems — Floating-Point arithmetic`标准。</br>

### الكود المكمل
#### تعريف
"المكمل" هو *تمثيل الأرقام الموقعة في أجهزة الكمبيوتر*. </br>

#### طريقة
"الكود المكمل" لـ "الأرقام الموجبة" و"0" هو *الرقم نفسه بالإضافة إلى أعلى بت 0*. "المكمل" لـ "الرقم السالب" هو *عكس قيمته المطلقة بمقدار البت وإضافة 1*. </br>

### معيار النقطة العائمة
#### تعريف
يعتمد "معيار الأرقام ذات الفاصلة العائمة" معيار `ISO/IEC 60559 Information technology — Microprocessor Systems — Floating-Point arithmetic`. ويسمى هذا المعيار أيضًا "معيار IEEE الثنائي الحسابي للنقطة العائمة (IEEE 754)"</br>

الموقع الرسمي: https://www.iso.org/standard/80985.html</br>

#### طريقة
"القيمة الفعلية" لـ "رقم الفاصلة العائمة" تساوي "بت الإشارة" مضروبًا في "قيمة إزاحة الأس" مضروبة في "القيمة الكسرية". للحصول على تعريفات مفصلة، ​​راجع معيار `ISO/IEC 60559 Information technology — Microprocessor Systems — Floating-Point arithmetic`. </br>

##### `32` بت `رقم النقطة العائمة`
| Bit length | Name | Bit number |
| ------ | ------ | ------ |
| 1 | Sign | 31 |
| 8 | Number | 30 to 23 positive value (actual exponent size + 127) |
| 23 | Significant digit | 22 to 0 bit number (starting from the right with 0) |

##### `64` بت `رقم النقطة العائمة`
| Bit length | Name | Bit number |
| ------ | ------ | ------ |
| 1 | Sign | 63 |
| 11 | Number | 62 to 52 positive value (actual exponent size + 1023) |
| 52 | Significant digit | 51 to 0 bit number (starting from the right with 0) |

## `types.h` الكود الكامل:
هناك أيضًا رموز ذات صلة بـ "النوع". فيما يلي رمز `types.h`:</br>
```C
// Copyright 2024 AQ author, All Rights Reserved.
// This program is licensed under the AQ License. You can find the AQ license in
// the root directory.

#ifndef AQ_AQVM_MEMORY_TYPES_H_
#define AQ_AQVM_MEMORY_TYPES_H_

#include <stdint.h>

// null - 0x00 - null type
// The null type simply represents an unknown type or a type that is not needed
// (e.g., returns nothing). Has no length.
typedef void aqnull;

// byte - 0x01 - 1 byte (8-bit) signed integer type
// Using two's complement storage. Generally used to store bool or char. From
// -128 to 127 (-2^7 to 2^7 - 1), inclusive.
typedef int8_t aqbyte;

// int - 0x02 - 4-byte (32-bit) signed integer type
// Stored in two's complement notation. From -2147483648 to 2147483647 (-2^31 to
// 2^31 - 1), inclusive.
typedef int aqint;

// long - 0x03 - 8-byte (64-bit) signed integer type
// Stored in two's complement notation. From -9223372036854775808 to
// 9223372036854775807 (-2^63 to 2^63 - 1), inclusive.
typedef int64_t aqlong;

// float - 0x04 - 4-byte (32-bit) single-precision floating point type
// Using ISO/IEC 60559 Information technology — Microprocessor Systems —
// Floating-Point arithmetic standard.
typedef float aqfloat;

// double - 0x05 - 8-byte (64-bit) double-precision floating point type
// Using ISO/IEC 60559 Information technology — Microprocessor Systems —
// Floating-Point arithmetic standard.
typedef double aqdouble;

// The part beyond 0x05 and within 0x0F is currently designated as a reserved
// type. The part beyond 0x0F cannot be used because it exceeds the 4-bit size
// limit.

#endif
```

> نحن نعمل بجد لتطوير "AQ Virtual Machine". إذا كنت ترغب في معرفة المزيد من المعلومات أو المشاركة في أعمال التطوير، يرجى متابعة موقعنا الرسمي: https://www.axa6.com وGithub: https://github.com/aq-org/AQ. </br>

> تم نشر هذه المقالة بناءً على ترخيص AQ: https://github.com/aq-org/AQ/blob/main/LICENSE، إذا لزم الأمر، يرجى تعديلها أو إعادة طباعتها وفقًا لترخيص AQ.