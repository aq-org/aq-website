---
publishDate: 2024-06-01T19:55:05+08:00
title: 一种优秀的虚拟机内存架构 - AQ
excerpt: 虚拟机内存架构直接影响虚拟机的性能和占用。设计一个优秀的架构可以有效提升性能和效率。本文将介绍AQ虚拟机使用的内存架构。
image: https://www.axa6.com/aq.png
category: Blog
tags:
  - AQ
  - Blog
metadata:
  canonical: https://www.axa6.com/一种优秀的虚拟机内存架构
---

# 简介
`虚拟机`内存架构直接影响虚拟机的性能和占用。设计一个优秀的架构可以有效提升性能和效率。</br>
本文将介绍`AQ虚拟机`使用的内存架构。</br>
通过对于`虚拟机`内存架构的优化，有助于`虚拟机`的*运行效率*和*减少占用*。如果可以，应该尽可能地平衡两者，使`虚拟机`达到最佳状态。</br>
> 在某些情况下，应该根据虚拟机的特殊需求进行不同的开发。</br>
> 例如：在`单片机`等*内存受限*情况下，需要尽可能地*减少占用*。</br>
> 而在`并行计算`等*性能敏感*情况，则需要侧重于*性能优化*。</br>

# 内存架构
## 基础内存架构
`AQ`采取了`寄存器`的基础内存架构，但与标准的`寄存器`架构有所不同，对`寄存器`架构进行了部分改进和优化。</br>
> 此处的`寄存器`并非`CPU`中的`寄存器`，而是在`内存`中模拟出的`虚拟寄存器`。
## 选择寄存器的原因
相较与`JAVA`、`Python`等主流语言虚拟机采取堆栈架构不同，`AQ`决定采取`寄存器`架构的原因是性能的优化与`字节码`的容易理解。</br>
虽然`堆栈`架构被普遍认为更容易移植和编写，但在实际的性能中会有一些损耗，对于`内存`的多次访问会减缓其速度，这是不可避免并且难以彻底优化的。因此，为了解决此处的*性能损耗*，`AQ`采用了`寄存器`架构。同时，从`字节码`的角度上说，`寄存器`架构的字节码*更容易理解*，其指令类似于`函数`的`参数`方式，而不是直接面对`堆栈`的众多操作。</br>
## `寄存器`架构的区别
### 标准的寄存器架构
标准的寄存器架构中，`寄存器`包含：</br>
1. `数据类型` - 寄存器将存储的数据的类型（如int、float、double等）
2. `数据` - 寄存器将存储的数据的值
3. （可选）标记 - 寄存器将存储的数据的标记（如变量、函数、类等）
4. （可选）引用 - 寄存器将存储的数据的引用（如对象的地址等）

尽管不同语言的`虚拟机`架构可能有所不同，但大致都是这样的形式，只是略有改变。</br>

而在`AQ`开发过程中曾使用了该架构，但是经过测试，其存在较大的内存占用。</br>
以下是`AQ`曾使用的`register.h`代码：
```C
// Copyright 2024 AQ authors, All Rights Reserved.
// This program is licensed under the AQ License. You can find the AQ license in
// the root directory.

#ifndef AQ_AQVM_MEMORY_REGISTER_H_
#define AQ_AQVM_MEMORY_REGISTER_H_

#include <stdbool.h>

enum AqvmMemoryRegister_ValueType {
  // TODO(Register): Waiting for the improvement of the register.
  AqvmMemoryRegisterValueType_INT,
  AqvmMemoryRegisterValueType_CONSTINT,
  AqvmMemoryRegisterValueType_FLOAT,
  AqvmMemoryRegisterValueType_CONSTFLOAT,
  AqvmMemoryRegisterValueType_DOUBLE,
  AqvmMemoryRegisterValueType_CONSTDOUBLE,
  AqvmMemoryRegisterValueType_LONG,
  AqvmMemoryRegisterValueType_CONSTLONG,
  AqvmMemoryRegisterValueType_CHARACTER,
  AqvmMemoryRegisterValueType_CONSTCHARACTER,
  AqvmMemoryRegisterValueType_BOOLEAN,
  AqvmMemoryRegisterValueType_CONSTBOOLEAN
};

union AqvmMemoryRegister_Value {
  // TODO(Register): Waiting for the improvement of the register.
  int int_value;
  const int const_int_value;
  float float_value;
  const float const_float_value;
  double double_value;
  const double const_double_value;
  long long_value;
  const long const_long_value;
  char character_value;
  const char const_character_value;
  bool boolean_value;
  const bool const_boolean_value;
};

struct AqvmMemoryRegister_Register {
  enum AqvmMemoryRegister_ValueType type;
  union AqvmMemoryRegister_Value value;
};

#endif
```
从上述代码可以看出，即使未加入可选内容，但由于`enum`类型的`AqvmMemoryRegister_ValueType`占用`4`字节，`union`类型的`AqvmMemoryRegister_Value`占用`8`字节，`struct`类型本身就会占用`12`字节内存。</br>

又由于`C`编译器的优化，`struct`类型的`AqvmMemoryRegister_Register`中`enum`类型的`type`为与`union`类型的`value`进行`内存对齐`，因此加入`4`字节的`填充内存`。使`struct`类型的`AqvmMemoryRegister_Register`占用`16`字节。

其中如果使用`int`等非`8`字节类型，则会有`4`字节的`填充内存`被浪费，从而造成内存损耗。因此在全部的寄存器中会有`4`-`8`字节的内存浪费。</br>

### `AQ`的寄存器架构
为了解决传统`寄存器`架构的占用问题，`AQ`结合了`JVM`的`栈帧`的`局部变量表`特点，对`寄存器`进行了优化，使占用问题显著减少。</br>

`AQ`的`寄存器`直接使用`int`指针存储数据，`size_t`存储占用内存大小。直接有效地减少了`填充内存`的损耗。</br>

```C
struct AqvmMemoryRegister_Register {
  uint32_t* value;
  size_t size;
};
```

类似与`栈帧`的设计可以将单个数据大小控制在`4`字节，保证对于`内存`的`利用率`，同时使内存占用问题有了很大改善。</br>

但使用该设计对于数据的`存储`和`加载`有较高要求，因为数据可能会被打乱，因此需要专门的`函数`配合该寄存器进行操作。</br>

```C
int AqvmMemoryRegister_IntStore(int value, struct AqvmMemoryRegister_Register* register, size_t index){
  if(register->size < index * sizeof(uint32_t) + sizeof(int)){
    // TODO(ERROR): Out of Memory.
    return -1;
  }
  memcpy(register -> value + index * sizeof(uint32_t), &value, sizeof(int));
  return 0;
}

// Wait for development.
```

To be continued...

> We are working hard on developing the `AQ virtual machine`. We would appreciate it if you could give us a star on Github. If you want to learn more or participate in the development work, please follow our official website: https://www.axa6.com and GitHub: https://github.com/aq-org/AQ.</br>

> This article is published under the AQ License: https://github.com/aq-org/AQ/blob/main/LICENSE. If needed, please adapt or reprint according to the AQ License.